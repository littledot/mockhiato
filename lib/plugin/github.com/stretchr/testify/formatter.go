package testify

import (
	"bufio"
	"bytes"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"gitlab.com/littledot/mockhiato/lib"
)

const (
	magic = "// Auto-generated by Mockhiato"
)

// NewTestifyFormatter creates a new testifyFormatter
func NewTestifyFormatter(config lib.Config) lib.Formatter {
	return &testifyFormatter{
		config: config,
	}
}

type testifyFormatter struct {
	config         lib.Config
	projectPackage string
}

func (r *testifyFormatter) SetProjectPackage(projectPackage string) {
	r.projectPackage = projectPackage
}

func (r *testifyFormatter) IsMockFile(file *os.File) bool {
	fileScanner := bufio.NewScanner(file)
	for i := 0; i < 6 && fileScanner.Scan(); i++ { // Check first 5 lines or EOF
		line := fileScanner.Text()
		if strings.HasPrefix(line, "//") { // Check 1st comment, which should be the 3rd line
			if line == magic { // Found magic string? File is a mock
				return true
			}
			break
		}
	}
	return false
}

func (r *testifyFormatter) GenerateMocks(spec *lib.Spec) {
	for _, pack := range spec.Packages {
		r.generateMock(pack)
	}
}

func (r *testifyFormatter) generateMock(pack *lib.Package) {
	if len(pack.Interfaces) == 0 { // Nothing to mock? Return early
		return
	}

	// Create file {package_name}_mocks.go
	if err := os.MkdirAll(r.config.OutputPath, 0755); err != nil {
		panic(err)
	}
	pkgName := pack.Interfaces[0].TObject.Pkg().Name()
	mockPath := fmt.Sprintf("%s/%s_mocks.go", r.config.OutputPath, pkgName)
	mockFile, err := os.Create(mockPath)
	if err != nil {
		panic(err)
	}
	defer mockFile.Close()

	buf := &bytes.Buffer{}
	pf := lib.NewPackageFormatter()
	pf.AnalyzePackage(pack.TPackage)

	// Write package
	buf.WriteString(fmt.Sprintf("package %s\n", filepath.Base(r.config.OutputPath)))

	// Write magic string
	buf.WriteString(magic + "\n")

	// Write imports
	vendorPath := r.projectPackage + "/vendor/" // TODO: use typesImporterFrom instead of types.Importer
	imports := []string{`"github.com/stretchr/testify/mock"`}
	for depPath, depAlias := range pf.PathToAlias {
		imports = append(imports, fmt.Sprintf(`%s "%s"`, depAlias, strings.TrimPrefix(depPath, vendorPath)))
	}
	buf.WriteString("import(\n")
	buf.WriteString(strings.Join(imports, "\n"))
	buf.WriteString("\n)\n")

	for _, iface := range pack.Interfaces {
		// Write struct
		interfaceName := iface.TObject.Name()
		buf.WriteString(fmt.Sprintf("// %s implements %s.%s\n", interfaceName, pkgName, interfaceName))
		buf.WriteString(fmt.Sprintf("type %s struct { mock.Mock }\n", interfaceName))

		for i := 0; i < iface.TInterface.NumMethods(); i++ {
			// Write method
			method := iface.TInterface.Method(i)
			signature := method.Type().(*types.Signature)

			paramNames := []string{}
			paramExprs := []string{}
			for j := 0; j < signature.Params().Len(); j++ {
				param := signature.Params().At(j)
				varName := "p" + strconv.Itoa(j)
				paramNames = append(paramNames, varName)
				paramExprs = append(paramExprs, varName+" "+pf.ObjectTypeString(param))
			}

			if signature.Variadic() { // Variadic method? Replace last parameter's [] with ... ("p1 []int" -> "p1 ...int")
				pos := signature.Params().Len() - 1
				paramExprs[pos] = strings.Replace(paramExprs[pos], "[]", "...", -1)
			}

			returnNames := []string{}
			returnTypes := []string{}
			verifyReturnLines := []string{}
			for j := 0; j < signature.Results().Len(); j++ {
				result := signature.Results().At(j)
				varName := "ret" + strconv.Itoa(j)
				returnNames = append(returnNames, varName)
				returnTypes = append(returnTypes, pf.ObjectTypeString(result))
				verifyReturnLines = append(verifyReturnLines, fmt.Sprintf("%s := ret.Get(%d).(%s)\n", varName, j, pf.ObjectTypeString(result)))
			}

			commentLine := fmt.Sprintf("// %s implements (%s.%s).%s\n", method.Name(), pkgName, interfaceName, method.Name())
			signatureLine := fmt.Sprintf("func (r *%s) %s(%s) (%s) {\n", interfaceName, method.Name(), strings.Join(paramExprs, ", "), strings.Join(returnTypes, ","))
			verifyInvokedLine := fmt.Sprintf("r.Called(%s)\n", strings.Join(paramNames, ", "))
			if signature.Results().Len() > 0 {
				verifyInvokedLine = "ret := " + verifyInvokedLine
			}
			returnLine := fmt.Sprintf("return %s\n}\n", strings.Join(returnNames, ", "))

			buf.WriteString(commentLine)
			buf.WriteString(signatureLine)
			buf.WriteString(verifyInvokedLine)
			for _, verifyReturnLine := range verifyReturnLines {
				buf.WriteString(verifyReturnLine)
			}
			buf.WriteString(returnLine)
		}

	}

	mockFile.Write(buf.Bytes())
	mockFile.Close()

	// Format generated code
	cmd := exec.Command("goimports", "-w", mockPath)
	if stdout, err := cmd.CombinedOutput(); err != nil {
		panic(string(stdout))
	}
}
