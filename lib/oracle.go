package lib

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/davecgh/go-spew/spew"
)

// Oracle parses Go projects, looking for interfaces to mock.
type Oracle struct {
}

func Run() {
	gen := &Oracle{}
	sources := gen.scanFiles()
	spew.Dump(sources)
	// gen.parseFile(sources)
	loaded := gen.loader(sources)
	gen.gen(loaded)
}

type scanResult struct {
	sources []string
}

func (r *Oracle) scanFiles() *scanResult {
	wd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	result := &scanResult{}
	err = filepath.Walk(wd, func(path string, info os.FileInfo, err error) error {
		if err != nil { // Something wrong? Skip
			return nil
		}
		if !strings.HasSuffix(path, ".go") { // Not Go source? Skip
			return nil
		}
		if strings.HasSuffix(path, "_test.go") { // Go test? Skip
			return nil
		}

		rel, err := filepath.Rel(wd, path)
		if err != nil {
			return nil
		}
		if strings.HasPrefix(rel, "vendor") { // Vendor directories? Skip TODO: make this configurable
			return filepath.SkipDir
		}

		if !strings.Contains(path, "demo.go") {
			return nil
		}

		result.sources = append(result.sources, path)
		return nil
	})
	if err != nil {
		panic(err)
	}

	return result
}

type loaderResult struct {
	Interfaces []*typeResult
	Imports    []*types.Package
}

type typeResult struct {
	object types.Object
	iface  *types.Interface
}

func (r *Oracle) loader(scan *scanResult) *loaderResult {
	cfg := &types.Config{
		Importer: importer.Default(),
	}
	fset := token.NewFileSet()
	files := []*ast.File{}
	for _, source := range scan.sources {
		f, err := parser.ParseFile(fset, source, nil, parser.AllErrors)
		if err != nil {
			panic(err)
		}
		files = append(files, f)
	}

	info := &types.Info{
		Defs: map[*ast.Ident]types.Object{},
		Uses: map[*ast.Ident]types.Object{},
	}
	_, err := cfg.Check("", fset, files, info)
	if err != nil {
		panic(err)
	}
	// spew.Dump(pkg)
	spew.Dump(info)

	loaderResult := &loaderResult{}
	for _, def := range info.Defs {
		if def == nil {
			continue
		}
		if _, ok := def.(*types.TypeName); !ok {
			continue
		}
		if !types.IsInterface(def.Type()) {
			continue
		}

		interfaceDef := def.Type().Underlying().(*types.Interface).Complete()
		result := &typeResult{
			object: def,
			iface:  interfaceDef,
		}
		spew.Printf("Found iface %s with %d func\n", def.Name(), interfaceDef.NumMethods())
		loaderResult.Interfaces = append(loaderResult.Interfaces, result)
	}

	for _, use := range info.Uses {
		pkgNameUse, ok := use.(*types.PkgName)
		if !ok {
			continue
		}
		loaderResult.Imports = append(loaderResult.Imports, pkgNameUse.Imported())
	}

	return loaderResult
}

func (r *Oracle) gen(loaded *loaderResult) {
	if len(loaded.Interfaces) == 0 { // Nothing to mock? Return early
		return
	}

	// Create file {package_name}_mocks.go
	if err := os.MkdirAll("mocks", os.ModeDir); err != nil {
		panic(err)
	}
	pkgName := loaded.Interfaces[0].object.Pkg().Name()
	mockPath := fmt.Sprintf("mocks/%s_mocks.go", strings.Replace(pkgName, "/", "_", -1))
	mockFile, err := os.Create(mockPath)
	if err != nil {
		panic(err)
	}
	defer mockFile.Close()

	buf := &bytes.Buffer{}

	// Write magic string
	buf.WriteString("// Package mocks is auto-generated by mockhiato\n")

	// Write package
	buf.WriteString("package mocks\n")

	// Write imports
	imports := []string{`"github.com/stretchr/testify/mock"`}
	for _, imported := range loaded.Imports {
		imports = append(imports, strconv.Quote(imported.Path()))
	}
	buf.WriteString("import(\n")
	buf.WriteString(strings.Join(imports, "\n"))
	buf.WriteString("\n)\n")

	for _, load := range loaded.Interfaces {
		// Write struct
		interfaceName := load.object.Name()
		buf.WriteString(fmt.Sprintf("// %s implements %s.%s\n", interfaceName, pkgName, interfaceName))
		buf.WriteString(fmt.Sprintf("type %s struct { mock.Mock }\n", interfaceName))

		for i := 0; i < load.iface.NumMethods(); i++ {
			// Write method
			method := load.iface.Method(i)
			signature := method.Type().(*types.Signature)

			paramNames := []string{}
			paramExprs := []string{}
			for j := 0; j < signature.Params().Len(); j++ {
				param := signature.Params().At(j)
				varName := "p" + strconv.Itoa(j)
				paramNames = append(paramNames, varName)
				paramExprs = append(paramExprs, varName+" "+GetTypeString(param))
			}

			if signature.Variadic() {
				pos := signature.Params().Len() - 1
				paramExprs[pos] = strings.Replace(paramExprs[pos], "[]", "...", -1)
			}

			returnNames := []string{}
			returnTypes := []string{}
			verifyReturnLines := []string{}
			for j := 0; j < signature.Results().Len(); j++ {
				result := signature.Results().At(j)
				varName := "ret" + strconv.Itoa(j)
				returnNames = append(returnNames, varName)
				returnTypes = append(returnTypes, GetTypeString(result))
				verifyReturnLines = append(verifyReturnLines, fmt.Sprintf("%s := ret.Get(%d).(%s)\n", varName, j, GetTypeString(result)))
			}

			commentLine := fmt.Sprintf("// %s implements %s.%s.%s(...)\n", method.Name(), pkgName, interfaceName, method.Name())
			signatureLine := fmt.Sprintf("func (r *%s) %s(%s) (%s) {\n", interfaceName, method.Name(), strings.Join(paramExprs, ", "), strings.Join(returnTypes, ","))
			verifyInvokedLine := fmt.Sprintf("r.Called(%s)\n", strings.Join(paramNames, ", "))
			if signature.Params().Len() > 0 {
				verifyInvokedLine = "ret := " + verifyInvokedLine
			}
			returnLine := fmt.Sprintf("return %s\n}\n", strings.Join(returnNames, ", "))

			buf.WriteString(commentLine)
			buf.WriteString(signatureLine)
			buf.WriteString(verifyInvokedLine)
			for _, getReturn := range verifyReturnLines {
				buf.WriteString(getReturn)
			}
			buf.WriteString(returnLine)
		}

	}
	mockFile.Write(buf.Bytes())
	mockFile.Close()

	// Format generated code
	cmd := exec.Command("goimports", "-w", mockPath)
	if stdout, e := cmd.CombinedOutput(); e != nil {
		panic(stdout)
	}
}

func GetTypeString(obj types.Object) string {
	spew.Dump(obj.Type())
	buf := &bytes.Buffer{}
	getTypeString(buf, obj.Type())
	return buf.String()
}

func getTypeString(buf *bytes.Buffer, obj types.Type) {
	switch objType := obj.(type) {
	case *types.Pointer:
		splits := strings.Split(objType.Elem().String(), "/")
		buf.WriteString("*")
		buf.WriteString(splits[len(splits)-1])
	case *types.Slice:
		buf.WriteString("[]")
		getTypeString(buf, objType.Elem())
	default:
		buf.WriteString(objType.String())
	}
}
